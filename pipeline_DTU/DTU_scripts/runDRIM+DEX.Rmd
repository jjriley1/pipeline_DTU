---
title: "runDRIM+DEXseq"
output: 
  html_document:
    df_print: paged
---

N.b. this script must be run in the "R-rstudio" environment:
"/shared/sudlab1/General/apps/conda/conda-install/envs/R-rstudio"

Import necessary libraries

```{r import_libs, warning=FALSE }
library(dplyr, quietly=T)
library(tximport, quietly=T)
library(DESeq2, quietly=T)
library(stringr, quietly=T)
library(ggplot2)
library(GenomicFeatures)
library(DRIMSeq)
library(stageR)
library(DEXSeq)
```

Load in the configs / run-specific information

```{r load_configs}
#load config and info file


#determine which comparison we are currently doing
folder_name = basename(getwd())

#we need to know what var1 values to filter by
filter_by_var1 = str_split(folder_name, "_in_")[[1]][1] %>% str_split("_vs_") %>% unlist()

#if there are 2 'vs' in the name then we are doing the
#interaction comparison, i.e. ~X + Y + X:Y
do_interaction = ifelse((length(grep("vs", str_split(folder_name, "_")[[1]])) == 2), TRUE, FALSE)

#if there is an 'in' present then we will need to filter
#the sample_table later, so we need to know if so
do_filter_by_var2 = "in" %in% str_split(folder_name, "_")[[1]]

#we also need to know what to filter by, e.g. wt or mutant, or both
if (do_filter_by_var2) {
  filter_by_var2 = str_split(folder_name, "_in_")[[1]][2] %>% str_split("_vs_") %>% unlist()
}

#determine how complex the file_naming is, i.e. 1 or 2 variables
num_vars = length(stringr::str_split(sample_names[1], "-")[[1]]) - 2
```

Generate sample table for tximport

```{r sample_table_from_sf}
#list all salmon files in quantification directory
quant_dir = "quantification.dir"
all_filenames = list.files(quant_dir, pattern="*.sf") 

#strip file name and apply to each item in the list
files<-file.path(quant_dir, all_filenames) 
sample_names = sapply(all_filenames, function(x) strsplit(x, "[.]")[[1]][1])
names(files) = sample_names

#create basic sample table
sample_table = data.frame(files=files, sample_id=sample_names) %>% 
  mutate(files = as.character(files))

#create column for each variable - this varies depending whether there are 1 / 2 vars
sample_table = sample_table %>% 
  mutate(identifier=as.factor(stringr::str_split(sample_id, "-")[[1]][1])) %>% 
  mutate(replicate=as.numeric(stringr::str_extract(sample_id, "(?<=R)\\d+"))) %>%
  mutate(var1 = as.factor(stringr::str_split(sample_id, "-")[[1]][2]))

#rearrange it so its easier to read
sample_table = sample_table %>%
  transmute(sample_id = sample_id,
            identifier = identifier,
            var1 = var1,
            replicate = replicate,
            files = files)

#if there is a 2nd variable add it now and place it after var1
if (num_vars==2) {
  sample_table = sample_table %>% 
    mutate(var2 = as.factor(stringr::str_split(sample_id, "-")[[1]][3])) %>% 
    relocate(var2, .after=var1)
}
```

Need to filter rows for those included in the variables:
2 steps to this:
  - If 1 variable, we need to filter rows by those which are specified in design matrix
  e.g. if looking at hESC vs NPC, only rows for hESC and NPC should be kept, not HSCs. 
  - If 2 variables, we need to do the above but also filter rows which are in the 
  condition we are currently looking at:
    + e.g. if we are looking at hESC vs NPC in mutant, we need to filter for var2==mutant,
    if we are looking at hESC vs NPC in wt then we need to filter for var2==wt. If we are
    looking at hESC vs NPC in mutant vs wt then keep both, but disregard other interactors
    (in case there are more than 2 from the dataset).
    
```{r filter_sample_table}
sample_table = sample_table %>% dplyr::filter(var1 %in% filter_by_var1)

if (num_vars==2){
  sample_table = sample_table %>% dplyr::filter(var2 %in% filter_by_var2)
}
```

How many samples are in each condition?

```{r overview_table}
table(sample_table$var1)
```

Check the files exist

```{r check_files_exist}
files.exist(sample_table$files)
```
 
Created named list of files

```{r named_list_of_files}
files = sample_table$files
names(files) = sample_table$sample_id
head(files)
```

Import with tximport

```{r tximport}
txi = tximport(files, type="salmon", txOut=TRUE, countsFromAbundance="no")
cts = txi$counts
#remove any rows where there are no counts
cts = cts[rowSums(cts) > 0,]
```

### Transcript to gene mapping

Load tx2gene from csvdb_files and rename so it matches quantification convention

```{r}
txdf = read.delim("expression.dir/csvdb_files/tx2gene.txt")
txdf = txdf %>% transmute(GENEID = match_gene_id, TXNAME = transcript_id)
tab = table(txdf$GENEID)
txdf$ntx = tab[match(txdf$GENEID, names(tab))]
```

We need nrows to be same for both the txdf and cts so we need to manipulate both (just in case they differ)

```{r}
nrow(txdf)
nrow(cts)

cts.names=row.names(cts)
in_cts_not_txdf = base::setdiff(cts.names, txdf$TXNAME)
in_txdf_not_cts = base::setdiff(txdf$TXNAME, cts.names)

cts = cts[!(row.names(cts) %in% in_cts_not_txdf),]
txdf = txdf %>% filter(!TXNAME %in% in_txdf_not_cts)

nrow(txdf)
nrow(cts)
```

Now they should be the same!

### DRIMSeq

Create counts matrix with each row as a transcript, and each column as a sample

```{r}
library(data.table)
counts = data.frame(cts)
counts = setDT(counts, keep.rownames = TRUE)
colnames(counts)[which(names(counts) == "rn")] = "feature_id"
counts = merge(counts, txdf, by.x = "feature_id", by.y = "TXNAME")
counts = counts[,1:36]
counts = data.frame(counts)
counts = counts %>% relocate(GENEID) 
colnames(counts)[which(names(counts) == "GENEID")] = "gene_id"
row.names(counts) = counts$feature_id
```

~~~ to be continued... ~~~